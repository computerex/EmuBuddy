package main

import (
	"archive/zip"
	"bufio"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"time"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/theme"
	"fyne.io/fyne/v2/widget"
	"github.com/0xcafed00d/joystick"

	"github.com/emubuddy/gui/wiiu"
)

// Debug logging
var debugLog *os.File

func logDebug(format string, args ...interface{}) {
	if debugLog == nil {
		var err error
		debugLog, err = os.OpenFile(filepath.Join(baseDir, "launcher_debug.log"), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
		if err != nil {
			return
		}
	}
	msg := fmt.Sprintf("[%s] %s\n", time.Now().Format("15:04:05.000"), fmt.Sprintf(format, args...))
	debugLog.WriteString(msg)
	debugLog.Sync()
}

// TappableListItem is a container that captures taps and double-taps for list items
type TappableListItem struct {
	widget.BaseWidget
	Content       fyne.CanvasObject
	list          *widget.List
	itemID        widget.ListItemID
	onDoubleTap   func(widget.ListItemID)
	lastTapTime   time.Time
}

func NewTappableListItem(content fyne.CanvasObject) *TappableListItem {
	t := &TappableListItem{
		Content: content,
	}
	t.ExtendBaseWidget(t)
	return t
}

func (t *TappableListItem) SetListInfo(list *widget.List, id widget.ListItemID, onDoubleTap func(widget.ListItemID)) {
	t.list = list
	t.itemID = id
	t.onDoubleTap = onDoubleTap
}

func (t *TappableListItem) CreateRenderer() fyne.WidgetRenderer {
	return widget.NewSimpleRenderer(t.Content)
}

func (t *TappableListItem) Tapped(e *fyne.PointEvent) {
	now := time.Now()
	
	// Check for double-tap
	if now.Sub(t.lastTapTime) < 400*time.Millisecond {
		logDebug("Double-tap on item %d!", t.itemID)
		if t.onDoubleTap != nil {
			t.onDoubleTap(t.itemID)
		}
		t.lastTapTime = time.Time{}
		return
	}
	
	t.lastTapTime = now
	
	// Select this item in the list
	if t.list != nil {
		t.list.Select(t.itemID)
	}
}

func (t *TappableListItem) TappedSecondary(e *fyne.PointEvent) {}

type ROM struct {
	Name    string `json:"name"`
	URL     string `json:"url"`
	Size    string `json:"size"`
	Date    string `json:"date"`
	TitleID string `json:"titleId,omitempty"` // For Wii U games
	Region  string `json:"region,omitempty"`  // For Wii U games
}

type CoreConfig struct {
	Name   string `json:"name"`
	Dll    string `json:"dll"`              // Windows .dll (also used as fallback)
	So     string `json:"so,omitempty"`     // Linux .so override
	Dylib  string `json:"dylib,omitempty"`  // macOS .dylib override
}

// GetCorePath returns the appropriate core path for the current OS
func (c *CoreConfig) GetCorePath() string {
	switch runtime.GOOS {
	case "linux":
		if c.So != "" {
			return c.So
		}
		// Auto-convert from dll
		return strings.TrimSuffix(c.Dll, ".dll") + ".so"
	case "darwin":
		if c.Dylib != "" {
			return c.Dylib
		}
		// Auto-convert from dll
		return strings.TrimSuffix(c.Dll, ".dll") + ".dylib"
	default:
		return c.Dll
	}
}

type EmulatorConfig struct {
	Path  string       `json:"path"`
	Args  []string     `json:"args"`
	Cores []CoreConfig `json:"cores"`
	Name  string       `json:"name"`
}

type SystemConfig struct {
	ID                 string          `json:"id"`
	Name               string          `json:"name"`
	Dir                string          `json:"dir"`
	RomJsonFile        string          `json:"romJsonFile"`
	LibretroName       string          `json:"libretroName"`
	Emulator           EmulatorConfig  `json:"emulator"`
	StandaloneEmulator *EmulatorConfig `json:"standaloneEmulator"`
	FileExtensions     []string        `json:"fileExtensions"`
	NeedsExtract       bool            `json:"needsExtract"`
	SpecialDownload    string          `json:"specialDownload,omitempty"`
}

type SystemsConfig struct {
	Systems []SystemConfig `json:"systems"`
}

var systems map[string]SystemConfig
var systemsList []string
var favorites map[string]map[string]bool

var baseDir string
var romsDir string
var favoritesPath string

func init() {
	exe, err := os.Executable()
	if err != nil {
		panic(err)
	}

	exeDir := filepath.Dir(exe)

	if fileExists(filepath.Join(exeDir, "1g1rsets")) {
		baseDir = exeDir
	} else if fileExists(filepath.Join(filepath.Dir(exeDir), "1g1rsets")) {
		baseDir = filepath.Dir(exeDir)
	} else if fileExists(filepath.Join(filepath.Dir(filepath.Dir(exeDir)), "1g1rsets")) {
		baseDir = filepath.Dir(filepath.Dir(exeDir))
	} else {
		baseDir = exeDir
	}

	romsDir = filepath.Join(baseDir, "roms")
	favoritesPath = filepath.Join(baseDir, "favorites.json")

	loadSystemsConfig()
	loadFavorites()
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func loadSystemsConfig() {
	configPath := filepath.Join(baseDir, "systems.json")
	data, err := os.ReadFile(configPath)
	if err != nil {
		panic(fmt.Sprintf("Failed to load systems.json: %v", err))
	}

	var config SystemsConfig
	if err := json.Unmarshal(data, &config); err != nil {
		panic(fmt.Sprintf("Failed to parse systems.json: %v", err))
	}

	systems = make(map[string]SystemConfig)
	systemsList = make([]string, 0, len(config.Systems))
	for _, sys := range config.Systems {
		systems[sys.ID] = sys
		systemsList = append(systemsList, sys.ID)
	}
}

func loadFavorites() {
	favorites = make(map[string]map[string]bool)
	data, err := os.ReadFile(favoritesPath)
	if err != nil {
		return
	}
	json.Unmarshal(data, &favorites)
}

func saveFavorites() {
	data, _ := json.Marshal(favorites)
	os.WriteFile(favoritesPath, data, 0644)
}

// resolvePlatformPath converts Windows paths from systems.json to platform-specific paths
func resolvePlatformPath(windowsPath string) string {
	platform := runtime.GOOS

	if platform == "windows" {
		return windowsPath
	}

	// Convert to forward slashes
	path := filepath.ToSlash(windowsPath)

	if platform == "darwin" {
		// macOS-specific path resolution

		// Handle RetroArch
		if strings.Contains(path, "RetroArch/RetroArch-Win64/retroarch.exe") {
			return strings.Replace(path, "RetroArch/RetroArch-Win64/retroarch.exe", "RetroArch/RetroArch.app/Contents/MacOS/RetroArch", 1)
		}

		// Handle RetroArch cores
		// On macOS, cores are stored in ~/Library/Application Support/RetroArch/cores/
		// Path arrives as .dylib already (converted by GetCorePath())
		if strings.Contains(path, "cores/") && strings.HasSuffix(path, ".dylib") {
			coreName := filepath.Base(path)
			homeDir, _ := os.UserHomeDir()
			return filepath.Join(homeDir, "Library/Application Support/RetroArch/cores", coreName)
		}

		// Handle Dolphin
		if strings.Contains(path, "Dolphin/Dolphin-x64/Dolphin.exe") {
			return strings.Replace(path, "Dolphin/Dolphin-x64/Dolphin.exe", "Dolphin/Dolphin.app/Contents/MacOS/Dolphin", 1)
		}

		// Handle PCSX2
		if strings.Contains(path, "PCSX2/pcsx2-qt.exe") {
			// Find the actual .app bundle (version may vary)
			pcsx2Dir := filepath.Join(baseDir, "Emulators", "PCSX2")
			if entries, err := os.ReadDir(pcsx2Dir); err == nil {
				for _, entry := range entries {
					if strings.HasPrefix(entry.Name(), "PCSX2") && strings.HasSuffix(entry.Name(), ".app") {
						return fmt.Sprintf("Emulators/PCSX2/%s/Contents/MacOS/PCSX2-qt", entry.Name())
					}
				}
			}
			return strings.Replace(path, "PCSX2/pcsx2-qt.exe", "PCSX2/PCSX2.app/Contents/MacOS/PCSX2-qt", 1)
		}

		// Handle PPSSPP
		if strings.Contains(path, "PPSSPP/PPSSPPWindows64.exe") {
			return strings.Replace(path, "PPSSPP/PPSSPPWindows64.exe", "PPSSPP/PPSSPP.app/Contents/MacOS/PPSSPP", 1)
		}

		// Handle mGBA
		if strings.Contains(path, "mGBA/mGBA-0.10.5-win64/mGBA.exe") {
			return strings.Replace(path, "mGBA/mGBA-0.10.5-win64/mGBA.exe", "mGBA/mGBA.app/Contents/MacOS/mGBA", 1)
		}

		// Handle melonDS
		if strings.Contains(path, "melonDS/melonDS.exe") {
			return strings.Replace(path, "melonDS/melonDS.exe", "melonDS/melonDS.app/Contents/MacOS/melonDS", 1)
		}

		// Handle Azahar
		if strings.Contains(path, "Azahar/azahar.exe") {
			return strings.Replace(path, "Azahar/azahar.exe", "Azahar/azahar.app/Contents/MacOS/azahar", 1)
		}
	}

	if platform == "linux" {
		// Linux-specific path resolution

		// Handle RetroArch - it's an AppImage on Linux
		if strings.Contains(path, "RetroArch/RetroArch-Win64/retroarch.exe") {
			// Find the actual AppImage in the RetroArch directory
			retroarchDir := filepath.Join(baseDir, "Emulators", "RetroArch", "RetroArch-Linux-x86_64")
			if entries, err := os.ReadDir(retroarchDir); err == nil {
				for _, entry := range entries {
					if strings.HasSuffix(strings.ToLower(entry.Name()), ".appimage") {
						return fmt.Sprintf("Emulators/RetroArch/RetroArch-Linux-x86_64/%s", entry.Name())
					}
				}
			}
			return "Emulators/RetroArch/RetroArch-Linux-x86_64/RetroArch-Linux-x86_64.AppImage"
		}

		// Handle RetroArch cores - .dll -> .so, and update path for Linux
		if strings.Contains(path, "cores/") && strings.HasSuffix(path, ".dll") {
			// Change extension and update the RetroArch path
			path = strings.TrimSuffix(path, ".dll") + ".so"
			path = strings.Replace(path, "RetroArch-Win64", "RetroArch-Linux-x86_64", 1)
			return path
		}

		// Handle PCSX2 - find the AppImage in the PCSX2 folder
		if strings.Contains(path, "PCSX2/pcsx2-qt.exe") {
			pcsx2Dir := filepath.Join(baseDir, "Emulators", "PCSX2")
			if entries, err := os.ReadDir(pcsx2Dir); err == nil {
				for _, entry := range entries {
					if strings.HasSuffix(strings.ToLower(entry.Name()), ".appimage") {
						return fmt.Sprintf("Emulators/PCSX2/%s", entry.Name())
					}
				}
			}
			return "Emulators/PCSX2/pcsx2.AppImage"
		}

		// Handle PPSSPP - find the AppImage in the PPSSPP folder
		if strings.Contains(path, "PPSSPP/PPSSPPWindows64.exe") {
			ppssppDir := filepath.Join(baseDir, "Emulators", "PPSSPP")
			if entries, err := os.ReadDir(ppssppDir); err == nil {
				for _, entry := range entries {
					if strings.HasSuffix(strings.ToLower(entry.Name()), ".appimage") {
						return fmt.Sprintf("Emulators/PPSSPP/%s", entry.Name())
					}
				}
			}
			return "Emulators/PPSSPP/ppsspp.AppImage"
		}

		// Handle mGBA - find the AppImage in the mGBA folder
		if strings.Contains(path, "mGBA/mGBA-0.10.5-win64/mGBA.exe") {
			mgbaDir := filepath.Join(baseDir, "Emulators", "mGBA")
			if entries, err := os.ReadDir(mgbaDir); err == nil {
				for _, entry := range entries {
					if strings.HasSuffix(strings.ToLower(entry.Name()), ".appimage") {
						return fmt.Sprintf("Emulators/mGBA/%s", entry.Name())
					}
				}
			}
			return "Emulators/mGBA/mgba.AppImage"
		}

		// Handle melonDS - find the AppImage in the melonDS folder
		if strings.Contains(path, "melonDS/melonDS.exe") {
			melondsDir := filepath.Join(baseDir, "Emulators", "melonDS")
			if entries, err := os.ReadDir(melondsDir); err == nil {
				for _, entry := range entries {
					if strings.HasSuffix(strings.ToLower(entry.Name()), ".appimage") {
						return fmt.Sprintf("Emulators/melonDS/%s", entry.Name())
					}
				}
			}
			return "Emulators/melonDS/melonDS.AppImage"
		}

		// Handle Azahar - find the AppImage in the Azahar folder
		if strings.Contains(path, "Azahar/azahar.exe") {
			azaharDir := filepath.Join(baseDir, "Emulators", "Azahar")
			if entries, err := os.ReadDir(azaharDir); err == nil {
				for _, entry := range entries {
					if strings.HasSuffix(strings.ToLower(entry.Name()), ".appimage") {
						return fmt.Sprintf("Emulators/Azahar/%s", entry.Name())
					}
				}
			}
			return "Emulators/Azahar/azahar.AppImage"
		}

		// Handle Dolphin - currently Flatpak, but if installed as AppImage
		if strings.Contains(path, "Dolphin/Dolphin-x64/Dolphin.exe") {
			dolphinDir := filepath.Join(baseDir, "Emulators", "Dolphin")
			// Check for AppImage first
			if entries, err := os.ReadDir(dolphinDir); err == nil {
				for _, entry := range entries {
					if strings.HasSuffix(strings.ToLower(entry.Name()), ".appimage") {
						return fmt.Sprintf("Emulators/Dolphin/%s", entry.Name())
					}
				}
			}
			// Dolphin is a Flatpak on Linux - return a special marker that launchGame can handle
			return "flatpak:org.DolphinEmu.dolphin-emu"
		}
	}

	return windowsPath
}

// App holds the application state
type App struct {
	window          fyne.Window
	windowFocused   bool
	currentSystem   string
	allGames        []ROM
	filteredGames   []ROM
	showFavsOnly    bool
	romCache        map[string]bool
	selectedGameIdx int
	selectedSysIdx  int
	focusOnGames    bool // true = game list focused, false = system list focused
	dialogOpen      bool

	// Emulator choice state
	choosingEmulator    bool
	emulatorChoices     []string
	emulatorPaths       []string
	emulatorArgs        [][]string
	selectedEmulatorIdx int
	pendingGame         ROM
	
	// Mouse double-click tracking
	lastClickTime time.Time
	lastClickIdx  int

	// UI elements
	systemList        *widget.List
	gameList          *widget.List
	statusBar         *widget.Label
	searchEntry       *widget.Entry
	searchQuery       string
	instructions      *widget.Label
	favsCheck         *widget.Check
	launchBtn         *widget.Button
	
	// Emulator choice UI
	emulatorList      *widget.List
	emulatorSelectBtn *widget.Button
	emulatorCancelBtn *widget.Button
	mainSplit         *container.Split
	gamePanel         *fyne.Container
	emulatorPanel     *fyne.Container
}

// isSetupComplete checks if emulators have been installed
func isSetupComplete() bool {
	emulatorsDir := filepath.Join(baseDir, "Emulators")
	
	// Check if Emulators directory exists
	info, err := os.Stat(emulatorsDir)
	if err != nil || !info.IsDir() {
		return false
	}
	
	// Check if there's at least one subdirectory (an installed emulator)
	entries, err := os.ReadDir(emulatorsDir)
	if err != nil {
		return false
	}
	
	for _, entry := range entries {
		if entry.IsDir() {
			// Found at least one emulator folder
			return true
		}
	}
	
	return false
}

// runSetupAndExit launches the setup program and exits the launcher
func runSetupAndExit() {
	var setupPath string
	
	switch runtime.GOOS {
	case "windows":
		setupPath = filepath.Join(baseDir, "EmuBuddySetup.exe")
	case "darwin":
		setupPath = filepath.Join(baseDir, "EmuBuddySetup-macos")
	default:
		setupPath = filepath.Join(baseDir, "EmuBuddySetup-linux")
	}
	
	// Check if setup exists
	if !fileExists(setupPath) {
		fmt.Println("Setup program not found:", setupPath)
		fmt.Println("Please run EmuBuddySetup first to install emulators.")
		os.Exit(1)
	}
	
	// Make executable on Unix
	if runtime.GOOS != "windows" {
		os.Chmod(setupPath, 0755)
	}
